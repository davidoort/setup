"use strict";
/*!
 *  Appenders.ts
 *  AUF
 *
 *  Created by Johan Blumenberg on 2016-12-29
 *  Copyright 2016 Microsoft. All rights reserved.
 *
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AufLog_1 = require("./AufLog");
var LogFactory_1 = require("./LogFactory");
/**
 * Abstract base class for writing log appenders.
 */
var AbstractLogAppender = (function () {
    function AbstractLogAppender(formatter) {
        this._formatter = formatter || new StandardLogFormatter();
    }
    AbstractLogAppender.prototype.formatter = function () {
        return this._formatter;
    };
    AbstractLogAppender.prototype.receiveAll = function () {
        return false;
    };
    AbstractLogAppender.prototype.levels = function () {
        return null;
    };
    return AbstractLogAppender;
}());
exports.AbstractLogAppender = AbstractLogAppender;
function toHex(v) {
    return (0x100000000 + v).toString(16).substr(-8);
}
function pad(value, width) {
    return (1000000000000 + value).toString(10).substr(-width);
}
/**
 * Flags controlling how an instance of the standard log formatter will format log messages.
 */
var SLF_Flags;
(function (SLF_Flags) {
    SLF_Flags[SLF_Flags["Timestamp"] = 1] = "Timestamp";
    SLF_Flags[SLF_Flags["Component"] = 4] = "Component";
    SLF_Flags[SLF_Flags["Level"] = 8] = "Level";
    SLF_Flags[SLF_Flags["FullDate"] = 32] = "FullDate";
    SLF_Flags[SLF_Flags["LogId"] = 64] = "LogId";
})(SLF_Flags = exports.SLF_Flags || (exports.SLF_Flags = {}));
/**
 * Create a log formatter that formats log messages as:
 *
 *   HH:MM:SS.mmm [&lt;level&gt;] [&lt;component&gt;] &lt;msg&gt;\n
 *
 * HH:MM:SS.mmmm is the log timestamp with millisecond precision
 * &lt;level&gt; is the log level of the message
 * &lt;component&gt; is the name of the component where the message was logged
 * &lt;msg&gt; is the printf style format string formatted using the provided arguments
 *
 * Parts of the format can be disabled using the provided flags. See SLF_Flags.
 * By default all parts are enabled.
 */
var StandardLogFormatter = (function () {
    function StandardLogFormatter(flags) {
        if (flags === void 0) { flags = 0xFFFFFFFF; }
        this._flags = flags;
    }
    StandardLogFormatter.prototype.format = function (md, id, fmt, args) {
        var header = "";
        if (this._flags & SLF_Flags.FullDate) {
            header += new Date(md.timestamp).toISOString() + ' ';
        }
        else if (this._flags & SLF_Flags.Timestamp) {
            var t = new Date(md.timestamp);
            header += pad(t.getHours(), 2) + ':' + pad(t.getMinutes(), 2) + ':' + pad(t.getSeconds(), 2) + '.' + pad(t.getMilliseconds(), 2) + ' ';
        }
        if (this._flags & SLF_Flags.LogId) {
            header += '[#' + toHex(id) + '-' + (md.component.safe() ? 'S' : 'u') + '] ';
        }
        if (this._flags & SLF_Flags.Level) {
            header += '[' + LogFactory_1.LogFactory.levelToString(md.level) + '] ';
        }
        if (this._flags & SLF_Flags.Component) {
            header += '[' + md.component.name() + '] ';
        }
        if (fmt || fmt === "") {
            return header + AufLog_1.vsprintf(fmt, args);
        }
        else {
            return header + toHex(id) + ': ' + args.join(' ');
        }
    };
    return StandardLogFormatter;
}());
exports.StandardLogFormatter = StandardLogFormatter;
// Set store native console functions and create smooth fallbacks
// console.debug is not connected to anything on android, so should not be used
var _nativeConsole = console;
var _nativeConsoleLog = console.log || function () { };
var _nativeConsoleInfo = console.info || _nativeConsoleLog;
var _nativeConsoleWarn = console.warn || _nativeConsoleInfo;
var _nativeConsoleError = console.error || _nativeConsoleWarn;
/**
 * Appender that outputs logs to the console object
 */
var ConsoleAppender = (function (_super) {
    __extends(ConsoleAppender, _super);
    function ConsoleAppender() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ConsoleAppender.prototype.log = function (md, logId, fmt, args) {
        args = args.slice(0);
        var log = (md.level <= AufLog_1.LogLevel.Debug3) ? _nativeConsoleLog :
            (md.level <= AufLog_1.LogLevel.Debug1) ? _nativeConsoleInfo :
                (md.level <= AufLog_1.LogLevel.Warning) ? _nativeConsoleWarn :
                    _nativeConsoleError;
        if (logId === -1) {
            var line = this.formatter().format(md, logId, "", []);
            if (typeof args[0] === 'string') {
                line += args.shift();
            }
            log.apply(_nativeConsole, [line].concat(args));
        }
        else {
            var m = void 0;
            var extra = [];
            while (m = fmt.match(/\s*%@\s*$/)) {
                fmt = fmt.substr(0, fmt.length - m[0].length);
                extra.unshift(args.pop());
            }
            var line = this.formatter().format(md, logId, fmt, args);
            log.apply(_nativeConsole, [line].concat(extra));
        }
    };
    return ConsoleAppender;
}(AbstractLogAppender));
exports.ConsoleAppender = ConsoleAppender;
var ChainedLogAppender = (function () {
    function ChainedLogAppender(chained) {
        this._chained = chained;
    }
    ChainedLogAppender.prototype.log = function (md, logId, fmt, args) {
        this._chained.log(md, logId, fmt, args);
    };
    ChainedLogAppender.prototype.receiveAll = function () {
        return this._chained.receiveAll();
    };
    ChainedLogAppender.prototype.levels = function () {
        return this._chained.levels();
    };
    return ChainedLogAppender;
}());
exports.ChainedLogAppender = ChainedLogAppender;
var LevelWrappedAppender = (function (_super) {
    __extends(LevelWrappedAppender, _super);
    function LevelWrappedAppender(chained, levels) {
        var _this = _super.call(this, chained) || this;
        _this._levels = levels;
        return _this;
    }
    LevelWrappedAppender.prototype.levels = function () {
        return this._levels;
    };
    return LevelWrappedAppender;
}(ChainedLogAppender));
function wrapAppenderWithLogLevels(appender, levels) {
    return new LevelWrappedAppender(appender, levels);
}
exports.wrapAppenderWithLogLevels = wrapAppenderWithLogLevels;
