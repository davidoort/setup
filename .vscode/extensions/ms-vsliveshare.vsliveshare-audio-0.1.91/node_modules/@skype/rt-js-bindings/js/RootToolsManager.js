"use strict";
/*!
 *  RootToolsManager.ts
 *  AUF
 *
 *  Created by Johan Blumenberg on 2016-12-29
 *  Copyright 2016 Microsoft. All rights reserved.
 *
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var SyncTasks = require("synctasks");
var LogFactory_1 = require("./LogFactory");
var AufLog_1 = require("./AufLog");
var Appenders_1 = require("./Appenders");
var log = LogFactory_1.LogFactory.instance().component('RootToolsManager');
LogFactory_1.LogFactory.instance().declareComponentSafe('RootToolsManager', true);
var TENANT_ID = '638b8ba2bae14e07aa5d73ddb5d5e5c5-297b8412-5df3-4a83-83c4-7b76c6c5d3f0-7104';
var BuildType;
(function (BuildType) {
    BuildType[BuildType["InternalBuild"] = 0] = "InternalBuild";
    BuildType[BuildType["PublicBuild"] = 1] = "PublicBuild";
})(BuildType = exports.BuildType || (exports.BuildType = {}));
var g_buildType = BuildType.InternalBuild;
function setBuildType(type) {
    var prev = g_buildType;
    g_buildType = type;
    return prev;
}
exports.setBuildType = setBuildType;
function toHex(v) {
    return (0x100000000 + v).toString(16).substr(-8);
}
function map(obj, f) {
    var a = [];
    for (var k in obj) {
        a.push(f(k, obj[k]));
    }
    return a;
}
function arrayEquals(a, b, compare) {
    if (a == null)
        return (b == null || b.length === 0);
    if (b == null)
        return (a == null || a.length === 0);
    if (a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
            if (!compare(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    return false;
}
function matcherEquals(a, b) {
    if (a == null)
        return (b == null);
    if (b == null)
        return (a == null);
    return a.arg === b.arg && a.op === b.op && a.value === b.value;
}
function conditionEquals(a, b) {
    if (a == null)
        return (b == null || b.logId === 0);
    if (b == null)
        return (a == null || a.logId === 0);
    return a.logId === b.logId && a.name === b.name && arrayEquals(a.matchers, b.matchers, matcherEquals);
}
function filterEqualsToNativeFilter(a, b) {
    if (a == null)
        return (b == null);
    if (b == null)
        return (a == null);
    return a.component === b.component && a.parsedLevel === b.level;
}
function filterEquals(a, b) {
    if (a == null)
        return (b == null);
    if (b == null)
        return (a == null);
    return a.component === b.component && a.level === b.level;
}
var Trigger = (function (_super) {
    __extends(Trigger, _super);
    function Trigger(rtMan, triggerCallback, config) {
        var _this = _super.call(this) || this;
        _this._unmetConditions = [];
        _this._rtMan = rtMan;
        _this._triggerCallback = triggerCallback;
        _this._ecsConfig = config;
        _this.resetConditions();
        return _this;
    }
    Trigger.prototype.config = function () {
        return this._ecsConfig;
    };
    Trigger.prototype.configEquals = function (config) {
        return this._ecsConfig.includeUnsafe === config.includeUnsafe &&
            this._ecsConfig.mutualSubmissionType === config.mutualSubmissionType &&
            this._ecsConfig.name === config.name &&
            this._ecsConfig.reenableAfterTriggering === config.reenableAfterTriggering &&
            this._ecsConfig.experimentTarget === config.experimentTarget &&
            conditionEquals(this._ecsConfig.resetCondition, config.resetCondition) &&
            arrayEquals(this._ecsConfig.conditions, config.conditions, conditionEquals) &&
            arrayEquals(this._ecsConfig.filters, config.filters, filterEquals);
    };
    Trigger.prototype.nativeConfigEquals = function (config) {
        return this._ecsConfig.includeUnsafe === config.includeUnsafe &&
            this._ecsConfig.name === config.name &&
            this._ecsConfig.reenableAfterTriggering === config.reenableAfterTriggering &&
            conditionEquals(this._ecsConfig.resetCondition, config.resetCondition) &&
            arrayEquals(this._ecsConfig.conditions, config.conditions, conditionEquals) &&
            arrayEquals(this._ecsConfig.filters, config.filters, filterEqualsToNativeFilter);
    };
    Trigger.prototype.needReset = function (config) {
        return !this.configEquals(config);
    };
    Trigger.prototype.resetConditions = function () {
        this._unmetConditions = [];
        for (var i = 0; i < this._ecsConfig.conditions.length; i++) {
            this._unmetConditions.push(i);
        }
    };
    Trigger.prototype.matcherMatches = function (matcher, args) {
        if (matcher.arg >= args.length) {
            return false;
        }
        else {
            var arg = args[matcher.arg];
            var value = (typeof arg === 'string') ? matcher.value : parseInt(matcher.value, 10);
            if (matcher.op === '=' || matcher.op === '==') {
                return arg === value;
            }
            else if (matcher.op === '!=') {
                return arg !== value;
            }
            else if (matcher.op === '<') {
                return arg < value;
            }
            else if (matcher.op === '<=') {
                return arg <= value;
            }
            else if (matcher.op === '>') {
                return arg > value;
            }
            else if (matcher.op === '>=') {
                return arg >= value;
            }
            else if (matcher.op.toUpperCase() === 'CONTAINS') {
                return ('' + arg).indexOf(matcher.value) >= 0;
            }
            else {
                return false;
            }
        }
    };
    Trigger.prototype.conditionMatches = function (condition, logId, args) {
        if (logId !== condition.logId) {
            return false;
        }
        if (condition.matchers) {
            for (var i = 0; i < condition.matchers.length; i++) {
                if (!this.matcherMatches(condition.matchers[i], args)) {
                    return false;
                }
            }
        }
        return true;
    };
    Trigger.prototype.log = function (md, logId, fmt, args) {
        if (this._unmetConditions.length === 0) {
            return;
        }
        if (md.component === log) {
            return;
        }
        var c = this._ecsConfig;
        if (c.resetCondition && this.conditionMatches(c.resetCondition, logId, args)) {
            log.debug4('LogTrigger %s: resetCondition met', c.name);
            this.resetConditions();
        }
        for (var i = 0; i < this._unmetConditions.length; i++) {
            var cond = this._unmetConditions[i];
            if (this.conditionMatches(c.conditions[cond], logId, args)) {
                log.debug4('LogTrigger %s: condition %s met', c.name, c.conditions[cond].name);
                this._unmetConditions.splice(i, 1);
                break;
            }
        }
        if (this._unmetConditions.length === 0) {
            log.debug1('LogTrigger %s has triggered, trying to send the log', c.name);
            this._triggerCallback.call(this._rtMan, c);
            if (c.reenableAfterTriggering) {
                this.resetConditions();
            }
        }
    };
    Trigger.prototype.receiveAll = function () {
        return true;
    };
    return Trigger;
}(Appenders_1.AbstractLogAppender));
var CircularBuffer = (function (_super) {
    __extends(CircularBuffer, _super);
    function CircularBuffer(includeUnsafe, circularBufferMaxSize, onBufferOwerflow) {
        var _this = _super.call(this) || this;
        _this._circularBuffer = [];
        _this._circularBufferMaxSize = 0;
        _this._onBufferOverflow = null;
        _this._circularBuffer = [];
        _this._circularBufferMaxSize = circularBufferMaxSize;
        _this._includeUnsafe = includeUnsafe;
        if (onBufferOwerflow) {
            _this._onBufferOverflow = onBufferOwerflow;
        }
        else {
            _this._onBufferOverflow = function () { return _this._circularBuffer.shift(); };
        }
        return _this;
    }
    CircularBuffer.prototype.formatMessage = function (args) {
        var result = [];
        for (var i = 0; i < args.length; i++) {
            if (typeof args[i] === 'string' || typeof args[i] === 'number') {
                result.push(args[i]);
            }
            else {
                result.push(JSON.stringify(args[i]));
            }
        }
        return result;
    };
    CircularBuffer.prototype.log = function (md, logId, fmt, args) {
        if (!this._includeUnsafe && !md.component.safe()) {
            return;
        }
        if (this._circularBuffer.length > this._circularBufferMaxSize) {
            return;
        }
        var entry = {
            md: md,
            logId: logId,
            messages: this.formatMessage(args)
        };
        this._circularBuffer.push(entry);
        if (this._circularBuffer.length > this._circularBufferMaxSize) {
            this._onBufferOverflow();
        }
    };
    CircularBuffer.prototype.visitReverseOrder = function (v) {
        for (var i = this._circularBuffer.length - 1; i >= 0; i--) {
            var log_1 = this._circularBuffer[i];
            if (!v(log_1.md, log_1.logId, log_1.messages)) {
                return;
            }
        }
    };
    CircularBuffer.prototype.visitForwardOrder = function (v) {
        for (var i = 0; i < this._circularBuffer.length; i++) {
            var log_2 = this._circularBuffer[i];
            if (!v(log_2.md, log_2.logId, log_2.messages)) {
                return;
            }
        }
    };
    CircularBuffer.prototype.needReset = function (includeUnsafe, circularBufferMaxSize) {
        return includeUnsafe !== this._includeUnsafe || circularBufferMaxSize !== this._circularBufferMaxSize;
    };
    CircularBuffer.prototype.dumpLogBuffer = function (filter, maxUploadSize, dumpingStats) {
        var _this = this;
        var lf = new BinaryLogFormatter(filter.reverse);
        var f = filter.filter.map(function (cl) { return { component: cl.component === 'root' ? '' : cl.component, parsedLevel: cl.level }; });
        var stats = dumpingStats ? dumpingStats : { matchedLines: 0, totalLines: 0 };
        var visit = null;
        if (filter.reverse) {
            visit = this.visitReverseOrder;
        }
        else {
            visit = this.visitForwardOrder;
        }
        visit.apply(this, [function (md, logId, args) {
                stats.totalLines++;
                if (_this.filterMatches(md, logId, args, f)) {
                    stats.matchedLines++;
                    lf.log(md.component, md.timestamp, md.level, logId, args);
                }
                if (!maxUploadSize)
                    return true; // continue dumping. don't care about size.
                return lf._data.length < maxUploadSize;
            }]);
        lf.close();
        return lf.data();
    };
    CircularBuffer.prototype.filterMatches = function (md, logId, args, filters) {
        for (var i = 0; i < filters.length; i++) {
            if (filters[i].component === '' ||
                md.component.name() === filters[i].component ||
                (md.component.name().substr(0, filters[i].component.length) === filters[i].component &&
                    md.component.name().charAt(filters[i].component.length) === '.')) {
                if (md.level >= filters[i].parsedLevel) {
                    return true;
                }
            }
        }
        return false;
    };
    CircularBuffer.prototype.clear = function () {
        this._circularBuffer = [];
    };
    CircularBuffer.prototype.size = function () {
        return this._circularBuffer.length;
    };
    CircularBuffer.prototype.empty = function () {
        return 0 === this.size();
    };
    CircularBuffer.prototype.capacity = function () {
        return this._circularBufferMaxSize;
    };
    return CircularBuffer;
}(Appenders_1.AbstractLogAppender));
exports.CircularBuffer = CircularBuffer;
var BinaryLogFormatter = (function () {
    function BinaryLogFormatter(_reverse) {
        this._reverse = _reverse;
        this._first = true;
        this._pending = [];
        this._components = {};
        this._componentCount = 0;
        this._lastts = 0;
        this._base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        // Header with flag ULOG_Base64. asuming it's little endian allways...
        this._data = 'ULOG2'
            + String.fromCharCode(0x21)
            + String.fromCharCode(0x20);
        if (_reverse) {
            // adding and ULOG_Reversed
            this._data += String.fromCharCode(0x22);
        }
        else {
            this._data += String.fromCharCode(0x20);
        }
        this._data += String.fromCharCode(0x20);
    }
    BinaryLogFormatter.prototype._add8 = function (c) {
        this._pending.push(c & 0xFF);
        if (this._pending.length === 3) {
            var a = (this._pending[0] << 16) +
                (this._pending[1] << 8) +
                (this._pending[2] << 0);
            var b = this._base64chars[(a >> 18) & 0x3F] +
                this._base64chars[(a >> 12) & 0x3F] +
                this._base64chars[(a >> 6) & 0x3F] +
                this._base64chars[(a >> 0) & 0x3F];
            this._data += b;
            this._pending = [];
        }
    };
    BinaryLogFormatter.prototype._add16 = function (c) {
        this._add8((c >> 8) & 0xFF);
        this._add8((c >> 0) & 0xFF);
    };
    BinaryLogFormatter.prototype._add32 = function (c) {
        this._add8((c >> 24) & 0xFF);
        this._add8((c >> 16) & 0xFF);
        this._add8((c >> 8) & 0xFF);
        this._add8((c >> 0) & 0xFF);
    };
    BinaryLogFormatter.prototype._add64 = function (c) {
        this._add32((c / 0x100000000) | 0);
        this._add32(c | 0);
    };
    BinaryLogFormatter.prototype._addS = function (s) {
        for (var i = 0; i < s.length; i++) {
            this._add8(s.charCodeAt(i));
        }
        this._add8(0); // '\0'
    };
    BinaryLogFormatter.prototype._close = function () {
        while (this._pending.length) {
            this._add8(0);
        }
    };
    BinaryLogFormatter.prototype.log = function (component, timestamp, level, id, msg) {
        var compId = this._components[component.name()];
        if (!compId) {
            compId = ++this._componentCount;
            this._components[component.name()] = compId;
            // Add component
            this._add8(2); // LMI_AddLogComponent
            this._add16(compId); // component id
            this._addS(component.name()); // component name
            this._addS(''); // static name
            this._addS(''); // description
            this._add8(component.safe() ? 1 : 0); // safe
        }
        var messageid = 128; // LMI_LogLine
        if (this._first) {
            messageid |= 2; // LMF_ThreadInfoIncluded
        }
        var diff = timestamp - this._lastts;
        this._lastts = timestamp;
        if (diff > -128 && diff < 128) {
            messageid |= 1; // LMF_RelativeTimestamp
        }
        this._add8(messageid); // message id
        if (messageid & 1) {
            this._add8(diff); // relative timestamp
        }
        else {
            this._add64(timestamp * 1000);
        }
        if (this._first) {
            // Add thread pool info in first log
            this._add32(1); // Thread ID
            this._add8(0); // Thread Pool ID
            this._add16(0); // Strand ID
        }
        this._add16(compId); // component id
        this._add8(level); // level
        this._add32(id); // LogId
        this._add8(msg.length); // args
        for (var i = 0; i < msg.length; i++) {
            this._add8(8); // LAT_CharPtr
            this._addS('' + msg[i]);
        }
        this._first = false;
    };
    BinaryLogFormatter.prototype.close = function () {
        this._add8(7); // LMI_End
        this._close();
    };
    BinaryLogFormatter.prototype.data = function () {
        return this._data;
    };
    return BinaryLogFormatter;
}());
function validateExperimentTarget(target) {
    return target === "Native"
        || target === "JavaScript"
        || target === "Mixed";
}
var RootToolsManagerImpl = (function () {
    function RootToolsManagerImpl() {
        this._maxUploadSize = 0;
        this._jsToNativeBuffer = null;
        this._jsToNativeBufferHandle = null;
        this._jsToNativeFlushTimer = null;
        this._jsToNativeFlushInterval = 0;
        this._triggers = {};
        this._defaultBuffers = [{
                size: 2 * 1024 * 1024,
                level: AufLog_1.LogLevel.Debug4
            }];
        this._defaultKillswitch = { blacklist: [], whitelist: [] };
        this._defaultBlacklists = { component: [], logline: [] };
        this._localLogLevels = {};
        this._defaultExperimentTarget = "Mixed";
        this._BRBCallback = null;
    }
    RootToolsManagerImpl.prototype.setDelegate = function (glue) {
        this._glue = glue;
        this.registerListeners();
    };
    RootToolsManagerImpl.prototype.isDelegateSet = function () {
        return (this._glue != null);
    };
    RootToolsManagerImpl.prototype.setNativeFunctions = function (native) {
        if (this._native) {
            this._native.log_config.removeLogTriggerListener(this);
        }
        this._native = native;
        if (this._native) {
            this._native.log_config.addLogTriggerListener(this);
        }
    };
    RootToolsManagerImpl.prototype.applyLogLevels = function () {
        var componentLevels = {};
        for (var c in this._localLogLevels) {
            componentLevels[c] = this._localLogLevels[c];
        }
        // '' applies better when sorting than 'root', and is also used in the native interface
        componentLevels[''] = componentLevels['root'] || AufLog_1.LogLevel.Debug4;
        delete componentLevels['root'];
        var clList = map(componentLevels, function (component, level) { return { component: component, level: level }; });
        clList.sort(function (a, b) { return a.component.length - b.component.length; });
        clList.forEach(function (cl) { return LogFactory_1.LogFactory.instance().component(cl.component).setLevel(cl.level); });
        if (this._native) {
            this._native.log_config.setLogLevelConfig(clList);
        }
    };
    RootToolsManagerImpl.prototype.setLocalLogLevelConfig = function (levels) {
        this._localLogLevels = levels;
        this.applyLogLevels();
    };
    RootToolsManagerImpl.prototype.parseMatcher = function (matcher) {
        if (matcher == null || matcher.arg == null || matcher.op == null || matcher.value == null)
            return null;
        var parsedMatcher = {
            arg: matcher.arg,
            op: matcher.op,
            value: matcher.value
        };
        return parsedMatcher;
    };
    RootToolsManagerImpl.prototype.parseCondition = function (condition) {
        if (condition == null || condition.logId == null) {
            return null;
        }
        if (condition.matchers && !(condition.matchers instanceof Array)) {
            return null;
        }
        var parsedCondition = {
            name: (condition.name || toHex(condition.logId)),
            logId: condition.logId,
            matchers: []
        };
        if (condition.matchers && condition.matchers.length) {
            for (var _i = 0, _a = condition.matchers; _i < _a.length; _i++) {
                var matcher = _a[_i];
                var parsedMatcher = this.parseMatcher(matcher);
                if (parsedMatcher)
                    parsedCondition.matchers.push(parsedMatcher);
            }
        }
        return parsedCondition;
    };
    RootToolsManagerImpl.prototype.parseFilter = function (filter) {
        if (filter == null || filter.component == null || filter.component.length === 0)
            return null;
        var parsedFilter = {
            component: filter.component,
            level: filter.level,
            parsedLevel: LogFactory_1.LogFactory.levelFromString(filter.level)
        };
        return parsedFilter;
    };
    RootToolsManagerImpl.prototype.parseConfig = function (config, ecsNs, ecsKey) {
        if (config == null) {
            return null;
        }
        if (!(config.conditions instanceof Array) || config.conditions.length == 0) {
            return null;
        }
        if (!(config.filters instanceof Array) || config.filters.length == 0) {
            return null;
        }
        if (config.resetCondition && !this.parseCondition(config.resetCondition)) {
            return null;
        }
        var parsedConfig = {
            name: (config.name || ecsNs + '->' + ecsKey),
            ecsNs: ecsNs,
            reenableAfterTriggering: (config.reenableAfterTriggering || false),
            mutualSubmissionType: (config.mutualSubmissionType || ''),
            includeUnsafe: (g_buildType !== BuildType.PublicBuild && (config.includeUnsafe || false)),
            experimentTarget: ((validateExperimentTarget(config.experimentTarget) && config.experimentTarget) || this._defaultExperimentTarget),
            conditions: [],
            resetCondition: (config.resetCondition == null) ? config.resetCondition : this.parseCondition(config.resetCondition),
            filters: []
        };
        for (var _i = 0, _a = config.conditions; _i < _a.length; _i++) {
            var condition = _a[_i];
            var parsedCondition = this.parseCondition(condition);
            if (parsedCondition)
                parsedConfig.conditions.push(parsedCondition);
        }
        for (var _b = 0, _c = config.filters; _b < _c.length; _b++) {
            var filter = _c[_b];
            var parsedFilter = this.parseFilter(filter);
            if (parsedFilter)
                parsedConfig.filters.push(parsedFilter);
        }
        if (parsedConfig.conditions.length === 0) {
            return null;
        }
        return parsedConfig;
    };
    RootToolsManagerImpl.prototype.isExperimentListed = function (list, ecsNamespace, ecsExperimentName, allowWildcard) {
        if (!list)
            return false;
        if (allowWildcard && list.some(function (i) { return i.namespace === '*'; })) {
            return true;
        }
        return list.some(function (i) { return (i.namespace === ecsNamespace) && (i.experiment === ecsExperimentName || i.experiment == '*'); });
    };
    RootToolsManagerImpl.prototype.isExperimentAllowed = function (killswitch, ecsNamespace, ecsExperiment) {
        return !this.isExperimentListed(killswitch.blacklist, ecsNamespace, ecsExperiment, true) || this.isExperimentListed(killswitch.whitelist, ecsNamespace, ecsExperiment, false);
    };
    RootToolsManagerImpl.prototype.findTrigger = function (triggers, ecsConfig) {
        for (var handle in triggers) {
            if (triggers[handle].configEquals(ecsConfig))
                return handle;
        }
        return null;
    };
    RootToolsManagerImpl.prototype.findTriggerByNativeConfig = function (triggers, ecsConfig) {
        for (var handle in triggers) {
            if (triggers[handle].nativeConfigEquals(ecsConfig))
                return handle;
        }
        return null;
    };
    RootToolsManagerImpl.prototype.OnEcsChange = function () {
        var _this = this;
        function forEachAsync(list, i, f) {
            if (i < list.length) {
                return f(list[i]).then(function () { return forEachAsync(list, i + 1, f); });
            }
            else {
                return SyncTasks.Resolved();
            }
        }
        if (this._glue == null)
            return SyncTasks.Resolved();
        return this._glue.fetchEcsConfig('SkypeRootTools', 'ULBaseline').then(function (config) {
            log.debug4("Reloading ULBaseline config - new config: %@", config);
            if (!config) {
                log.warn('No ULBaseline config');
                config = {};
            }
            _this._maxUploadSize = (config.logUpload && config.logUpload.maxSize) || 1024;
            var triggersToAdd = [];
            var triggersToRemove = _this._triggers;
            _this._triggers = {};
            var circularBufferMaxSize = ((config.logUpload && config.logUpload.maxSize) || 1024) / 100;
            var circularBufferEnabled = (config.circularBuffer && config.circularBuffer.enabled);
            var buffers = (config.circularBuffer && config.circularBuffer.buffers) || _this._defaultBuffers;
            var storeUnsafe = (config.circularBuffer && config.circularBuffer.storeUnsafe);
            _this._defaultExperimentTarget = (validateExperimentTarget(config.defaultExperimentTarget) && config.defaultExperimentTarget) || "Mixed";
            var killswitch = config.killswitch || _this._defaultKillswitch;
            var blacklists = config.blacklists || _this._defaultBlacklists;
            if (blacklists.component.length > 0)
                LogFactory_1.LogFactory.instance().setComponentBlacklist(blacklists.component);
            var componentLevels = {};
            (config.componentLevels || []).forEach(function (cl) { return componentLevels[cl.component] = cl.level; });
            var configPaths = config.configPaths || [];
            forEachAsync(configPaths, 0, function (configPath) { return _this._glue.fetchEcsConfig(configPath.ns, configPath.key).then(function (expOneOrArray) {
                var experimentArray = (expOneOrArray instanceof Array) ? expOneOrArray : [expOneOrArray];
                log.debug4("Reloading ECS config for %s->%s - new config: %@", configPath.ns, configPath.key, experimentArray);
                for (var _i = 0, experimentArray_1 = experimentArray; _i < experimentArray_1.length; _i++) {
                    var exp = experimentArray_1[_i];
                    if (exp == null)
                        continue;
                    var ecsExperiment = _this.parseConfig(exp, configPath.ns, configPath.key);
                    if (ecsExperiment == null) {
                        log.error("Failed to parse ECS config for %s->%s", configPath.ns, configPath.key);
                        continue;
                    }
                    if (ecsExperiment.experimentTarget !== "JavaScript" && ecsExperiment.experimentTarget !== "Mixed") {
                        log.debug4("Skipping %s->%s, targeted for %s", configPath.ns, configPath.key, ecsExperiment);
                        continue;
                    }
                    log.debug2("Parsed ECS config for %s->%s - %@", configPath.ns, configPath.key, ecsExperiment);
                    if (_this.isExperimentAllowed(killswitch, configPath.ns, ecsExperiment.name)) {
                        log.debug2("Allowing %s->%s:%s according to killswitch", configPath.ns, configPath.key, ecsExperiment.name);
                        circularBufferEnabled = true;
                        var handle = _this.findTrigger(triggersToRemove, ecsExperiment);
                        if (handle != null) {
                            log.debug2("Triggers updated, keeping trigger %s", ecsExperiment.name);
                            _this._triggers[handle] = triggersToRemove[handle];
                            delete triggersToRemove[handle];
                        }
                        else {
                            triggersToAdd.push(ecsExperiment);
                        }
                        if (ecsExperiment.filters) {
                            ecsExperiment.filters.forEach(function (cl) { return componentLevels[cl.component] = Math.min(componentLevels[cl.component] || 255, cl.parsedLevel); });
                        }
                        if (ecsExperiment.includeUnsafe) {
                            storeUnsafe = true;
                        }
                    }
                    else {
                        log.debug2("Disallowing %s->%s according to killswitch", configPath.ns, configPath.key);
                    }
                }
            }); }).always(function () {
                _this.applyLogLevels();
                for (var handle in triggersToRemove) {
                    log.debug2("Triggers updated, removing trigger %s", triggersToRemove[handle].config().name);
                    LogFactory_1.LogFactory.instance().removeAppender(+handle);
                }
                triggersToAdd.forEach(function (newConfig) {
                    log.debug2('Triggers updated, adding trigger %s', newConfig.name);
                    var trigger = new Trigger(_this, _this._triggered, newConfig);
                    var handle = LogFactory_1.LogFactory.instance().addAppender(trigger);
                    _this._triggers[String(handle)] = trigger;
                });
                // '' applies better when sorting than 'root', and is also used in the native interface
                componentLevels[''] = componentLevels['root'] || AufLog_1.LogLevel.Debug4;
                delete componentLevels['root'];
                if (_this._circularBuffer && (!circularBufferEnabled || _this._circularBuffer.needReset(storeUnsafe, circularBufferMaxSize))) {
                    log.debug2("Buffer updated, removing existing buffer");
                    LogFactory_1.LogFactory.instance().removeAppender(_this._circularBufferHandle);
                    _this._circularBuffer = null;
                    _this._circularBufferHandle = null;
                }
                else if (_this._circularBuffer) {
                    // if any filter settings changed - reapply log levels
                    if (Object.keys(triggersToRemove).length > 0 || triggersToAdd.length > 0) {
                        log.debug2("Buffer updated, reapplying log levels, removing log levels wrapper");
                        LogFactory_1.LogFactory.instance().removeAppender(_this._circularBufferHandle);
                        _this._circularBufferHandle = null;
                    }
                    else {
                        log.debug2("Buffer updated, no change");
                    }
                }
                if (circularBufferEnabled) {
                    if (!_this._circularBuffer) {
                        log.debug2("Buffer updated, adding new buffer (storeUnsafe=%d,maxSize=%s)", storeUnsafe, circularBufferMaxSize);
                        _this._circularBuffer = new CircularBuffer(storeUnsafe, circularBufferMaxSize);
                    }
                    if (_this._circularBufferHandle == null) {
                        log.debug2("Creating log level wrapper");
                        _this._circularBufferHandle = LogFactory_1.LogFactory.instance().addAppender(Appenders_1.wrapAppenderWithLogLevels(_this._circularBuffer, componentLevels), AufLog_1.AppenderFlags.InsertFront);
                    }
                }
                if (_this._native) {
                    var clList = map(componentLevels, function (component, level) { return { component: component, level: level }; });
                    clList.sort(function (a, b) { return a.component.length - b.component.length; });
                    _this._native.log_config.setLogBufferConfig(circularBufferEnabled, {
                        storeUnsafe: storeUnsafe,
                        buffers: buffers
                    }, clList);
                    var triggers = [];
                    for (var t in _this._triggers) {
                        var tr = _this._triggers[t].config();
                        triggers.push({
                            name: tr.name,
                            ecsNs: tr.ecsNs,
                            conditions: tr.conditions,
                            resetCondition: tr.resetCondition,
                            includeUnsafe: tr.includeUnsafe,
                            reenableAfterTriggering: tr.reenableAfterTriggering,
                            filters: tr.filters.map(function (f) { return { component: f.component, level: f.parsedLevel }; }),
                            dumpFile: false,
                            metadata: {}
                        });
                    }
                    _this._native.log_config.setLogTriggerConfig(triggers, {});
                }
            });
        });
    };
    RootToolsManagerImpl.prototype._send = function (config, data) {
        if (this._glue == null)
            return;
        this._glue.sendTelemetry(TENANT_ID, {
            logTriggerName: config.name,
            logEcsNs: config.ecsNs,
            logdata: data
        });
        log.debug4('LogSender::send, sent %d bytes', data.length);
    };
    RootToolsManagerImpl.prototype.triggered = function (config, timestamp) {
        // Ignore, matching is doned based on individual log line trigger notifications
    };
    RootToolsManagerImpl.prototype.triggeredPartially = function (config, md, logId, fmt, args) {
        var handle = this.findTriggerByNativeConfig(this._triggers, config);
        if (handle) {
            var _md = {
                level: md.level,
                component: LogFactory_1.LogFactory.instance().component(md.component),
                timestamp: md.timestamp
            };
            this._triggers[handle].log(_md, logId, fmt, args);
        }
    };
    RootToolsManagerImpl.prototype.reset = function (config) {
        var handle = this.findTriggerByNativeConfig(this._triggers, config);
        if (handle) {
            this._triggers[handle].resetConditions();
        }
    };
    RootToolsManagerImpl.prototype.dumpLogBuffer = function (filter, options) {
        if (this._circularBuffer) {
            var stats = { matchedLines: 0, totalLines: 0 };
            var data = this._circularBuffer.dumpLogBuffer(filter, this._maxUploadSize, stats);
            log.debug4("dumpLogBuffer: dumped %d of %d lines, size of payload: %d", stats.matchedLines, stats.totalLines, (data != null) ? data.length : 0);
            if (this._native) {
                var defered_1 = SyncTasks.Defer();
                this._native.log_config.mergeAndDumpLogBuffer(data, filter, options, function (data) { return defered_1.resolve(data); });
                return defered_1.promise();
            }
            else {
                return SyncTasks.Resolved(data);
            }
        }
        log.warn("dumpLogBuffer: no log buffer enabled");
        return SyncTasks.Rejected();
    };
    RootToolsManagerImpl.prototype._triggered = function (config) {
        var _this = this;
        var options = {
            compression: AufLog_1.LogFileCompression.Compress,
            encoding: AufLog_1.LogFileEncoding.Base64,
            encryption: AufLog_1.LogFileEncryption.Encrypted,
            maxRotations: 0,
            maxSize: this._maxUploadSize,
            reverse: true
        };
        var filter = {
            includeUnsafe: config.includeUnsafe,
            filter: config.filters.map(function (f) { return { component: f.component, level: f.parsedLevel }; }),
            reverse: true
        };
        this.dumpLogBuffer(filter, options).then(function (data) { return _this._send(config, data); });
    };
    RootToolsManagerImpl.prototype.sendBRBEvent = function (event) {
        try {
            log.debug2("sendBRBEvent %s", JSON.stringify(event));
            if (this._glue != null && typeof this._glue.sendLoggingEventToNative === "function") {
                var message = {
                    eventType: "uploadBRB",
                    mutualSubmissionType: "call",
                    payload: event
                };
                this._glue.sendLoggingEventToNative(JSON.stringify(message), "");
            }
        }
        catch (e) {
            log.error("sendBRBEvent %s: %s", e.name, e.message);
        }
    };
    RootToolsManagerImpl.prototype.setBRBCallback = function (callback) {
        log.debug2("setBRBCallback");
        if (this._glue == null) {
            log.warn("setBRBCallback: RootToolsManagerDelegate is not set");
            return;
        }
        if (typeof this._glue.setNativeLoggingEventCallback !== "function") {
            log.warn("setBRBCallback: RootToolsManagerDelegate missing setNativeLoggingEventCallback method");
            return;
        }
        this._BRBCallback = callback;
    };
    RootToolsManagerImpl.prototype.registerListeners = function () {
        var _this = this;
        if (this._glue == null || typeof this._glue.setNativeLoggingEventCallback !== "function") {
            log.warn("registerListeners: RootToolsManagerDelegate missing setNativeLoggingEventCallback method");
            return;
        }
        this._glue.setNativeLoggingEventCallback(function (message, auxiliaryPayload) { return _this.handleNativeLoggingEvent(message, auxiliaryPayload); });
    };
    RootToolsManagerImpl.prototype.handleNativeLoggingEvent = function (message, auxiliaryPayload) {
        try {
            log.debug2("Native Log event message: %s aux: %s", message, auxiliaryPayload);
            var parsed = JSON.parse(message);
            if (parsed.eventType && parsed.eventType === "uploadBRB") {
                if (typeof this._BRBCallback !== "function") {
                    log.warn("BRBCallback not set, ignoring native event");
                    return;
                }
                log.debug4("Sending BRB callback: %@", parsed.payload);
                this._BRBCallback(parsed.payload);
            }
            else if (parsed.eventType && parsed.eventType === "jsLogFileConfiguration") {
                this.handleLogFileConfigEvent(parsed);
            }
        }
        catch (e) {
            log.error("handleNativeLoggingEvent %s: %s", e.name, e.message);
        }
    };
    RootToolsManagerImpl.prototype.handleLogFileConfigEvent = function (message) {
        if (!message.payload)
            return;
        var config = message.payload;
        if (!config.enabled) {
            this.flushDisableJsToNativeLogging();
            return;
        }
        if (!config.chunkSize || !config.flushInterval)
            return;
        var chunkSize = config.chunkSize;
        var flushInterval = config.flushInterval;
        this.startJsToNativeLogging(chunkSize, flushInterval);
    };
    RootToolsManagerImpl.prototype.logExternalForDDL = function (log_message, parameters) {
        try {
            log.debug2("logExternalForDDL %s %s", log_message, parameters);
            if (this._glue != null && typeof this._glue.sendLoggingEventToNative === "function") {
                var ul_message = {
                    eventType: "logInSClog",
                    payload: {
                        message: log_message,
                        parameters: parameters
                    }
                };
                this._glue.sendLoggingEventToNative(JSON.stringify(ul_message), "");
            }
            else {
                log.warn("ignoring logExternalForDDL, delegate misconfigured");
            }
        }
        catch (e) {
            log.error("logExternalForDDL %s: %s", e.name, e.message);
        }
    };
    RootToolsManagerImpl.prototype.startJsToNativeLogging = function (chunkSize, flushInterval) {
        var _this = this;
        if (this._jsToNativeBuffer) {
            if (this._jsToNativeBuffer.capacity() === chunkSize && this._jsToNativeFlushInterval === flushInterval) {
                log.debug1("Same JS2Native settings received - doing nothing");
                return;
            }
            log.debug1("Reapplying js to native settings");
            this.flushDisableJsToNativeLogging();
        }
        this._jsToNativeBuffer = new CircularBuffer(true, chunkSize, function () {
            _this.onJsToNativeBufferReady(_this._jsToNativeBuffer);
        });
        this.setJsToNativeFlushTimeout(flushInterval);
        this._jsToNativeFlushInterval = flushInterval;
        this._jsToNativeBufferHandle = LogFactory_1.LogFactory.instance().addAppender(this._jsToNativeBuffer);
    };
    RootToolsManagerImpl.prototype.flushDisableJsToNativeLogging = function () {
        if (this._jsToNativeBuffer) {
            this.onJsToNativeBufferReady(this._jsToNativeBuffer);
        }
        this.plainDisableJsToNativeLogging();
    };
    RootToolsManagerImpl.prototype.plainDisableJsToNativeLogging = function () {
        this.clearJsToNativeFlushTimeout();
        if (this._jsToNativeBufferHandle) {
            LogFactory_1.LogFactory.instance().removeAppender(this._jsToNativeBufferHandle);
            this._jsToNativeBufferHandle = 0;
            this._jsToNativeBuffer = null;
            log.debug1("Disabling forwarding JS logs to native");
        }
    };
    RootToolsManagerImpl.prototype.onJsToNativeBufferReady = function (buffer) {
        if (this._glue != null && typeof this._glue.sendLoggingEventToNative === "function") {
            this.clearJsToNativeFlushTimeout();
            this.dumpJsToNativeBuffer(buffer);
            this.setJsToNativeFlushTimeout(this._jsToNativeFlushInterval);
        }
        else {
            this.plainDisableJsToNativeLogging();
        }
    };
    RootToolsManagerImpl.prototype.dumpJsToNativeBuffer = function (buffer) {
        if (buffer.empty())
            return;
        var data = buffer.dumpLogBuffer({ reverse: false, filter: [{ component: 'root', level: 0 }] });
        buffer.clear();
        var message = { eventType: "writeLogData" };
        this._glue.sendLoggingEventToNative(JSON.stringify(message), data);
    };
    RootToolsManagerImpl.prototype.clearJsToNativeFlushTimeout = function () {
        if (this._jsToNativeFlushTimer) {
            clearTimeout(this._jsToNativeFlushTimer);
            this._jsToNativeFlushTimer = null;
        }
    };
    RootToolsManagerImpl.prototype.setJsToNativeFlushTimeout = function (timeout) {
        var _this = this;
        if (this._jsToNativeFlushTimer || !timeout)
            return;
        this._jsToNativeFlushTimer = setTimeout(function () {
            _this._jsToNativeFlushTimer = null;
            _this.onJsToNativeBufferReady(_this._jsToNativeBuffer);
        }, timeout);
    };
    RootToolsManagerImpl.prototype.stopAsyncOperations = function () {
        this.flushDisableJsToNativeLogging();
    };
    return RootToolsManagerImpl;
}());
exports.RootToolsManager = new RootToolsManagerImpl();
