/*!
 *  AufLog.ts
 *  AUF
 *
 *  Created by Johan Blumenberg on 2016-12-29
 *  Copyright 2016 Microsoft. All rights reserved.
 *
 */
/**
 * Log levels.
 *
 * The default log level is set to LL_Debug4. This can be overridden for each component by doing:
 *   auf.LogFactory.instance().component(name).setLevel(level);
 * Setting a log level will set it for that component and for all its sub components. Sub components
 * can then be set to a different log level.
 *
 * During normal program execution, the logs should be clean. Everything that shows in the log
 * is an indication of a bug (except the LL_MetaData level logs, which should be very sparse).
 *
 * Lower log levels can be used for troubleshooting a particular problem.
 *
 * Logs will be available on clients for debugging by developers, but they will also be
 * uploaded to the cloud from all released clients. Because of this, it is important that the
 * size of the log files can be controlled. The available bandwidth will limit the size of a log
 * file uploaded to the cloud. Logs that are more important for troubleshooting the problem should
 * have a less verbose level, and the more verbose levels can be filtered out to acheive the desired
 * log file size.
 */
export declare enum LogLevel {
    /**
     * Trace level.
     * Suitable for logging function entry/exit.
     */
    Trace = 10,
    /**
     * The most detailed debug level, suitable for logging anything that can help a developer to understand
     * the flow of the application. There is no limit on the size of the logs on level LL_Debug6, but they will
     * likely not be uploaded to the cloud due to their size.
     * On level LL_Debug6 it is allowed to log large strings or other contents that require more memory to
     * handle on the client. It is not allowed on the less detailed debug levels.
     */
    Debug6 = 16,
    /**
     * Log level suitable for logging most low level events except for large chunks of data or large strings.
     */
    Debug5 = 18,
    /**
     * Log level suitable for logging most low level events except for large chunks of data or large strings.
     *
     * Note: Default log level is set to Debug4.
     */
    Debug4 = 20,
    /**
     * Log level suitable for logging a more detailed flow of events in the application.
     */
    Debug3 = 30,
    /**
     * Log level suitable for logging a more detailed flow of events in the application.
     */
    Debug2 = 40,
    /**
     * The least detailed debug level, suitable for logging of significant events in the application, for
     * example call started, call ended, or user login.
     * The goal is to be able to upload all LL_Debug1 logs for an entire call to the cloud after the call
     * is complete, also on devices that have limited bandwidth and memory.
     */
    Debug1 = 50,
    /**
     * Suitable for logging a warning when the app faced a potential problem that was mitigated without
     * affecting the user experience in any way.
     * Some examples are:
     * 1) When an external service could not be used, but a secondary service which performs the same
     * functions was available.
     * 2) When repeated attempts unexpectedly were required to access a given resource.
     * 3) When authentication fails, because this is most likely not an error but due to bad user input,
     * but it is very useful information when troubleshooting.
     */
    Warning = 60,
    /**
     * Error level.
     * Suitable for logging a significant problem that affected the user in some way.
     * For example, a database connection that failed, resulting in parts of the app being unusable.
     *
     * Something that might be an error, but might also be normal operation, should not be logged as
     * an error. For example, a library call failing to connect a socket or failing to lookup a host
     * name should be logged on a more verbose level, since that could also be normal operation.
     * Higher layers in the code should determine if it is considered an error, and make the appropriate
     * log. Enabling more verbose logs will then give more details about the error.
     */
    Error = 70,
    /**
     * Fatal errors.
     * Suitable for logging errors that are so serious that the program will abort.
     */
    Fatal = 80,
    /**
     * Suitable for logging information that would be useful to diagnose the app without access to the
     * device.
     * For example app and os versions.
     */
    MetaData = 90,
}
/**
 * A log component is used to identify different components of the code.
 * Each code component should have its own log component, to be able to
 * know which component posted the log line.
 *
 * Logging can be enabled or disabled per component, which makes it easy to
 * troubleshoot a problem in a certain component by setting its log level
 * to a lower value, without having the log flooded by log messages from
 * other components.
 *
 * Log components are organized in a tree hierarchy. Setting the log level
 * for one component also affects the log levels of its sub-components.
 *
 * Sub components are identified by the name they are given. A log component
 * name is composed by sub-component names separated by '.'.
 * For example the component "a" can have the sub components "a.b" and "a.c".
 */
export interface LogComponent {
    /**
     * The name of the log component
     * @return The name of the log component
     */
    name(): string;
    /**
     * The current log level of the component
     * @return The current log level of the component
     */
    level(): LogLevel;
    /**
     * Set the level for the component.
     * Everything logged on a level below this level will be discarded.
     * @param level New level for the component
     */
    setLevel(level: LogLevel): any;
    /**
     * If a component is safe it means all PII is properly tagged
     * @return true if safe
     */
    safe(): boolean;
    /**
     * Application-defined extended info
     * @return extended info
     */
    extendedInfo(): any | undefined;
    /**
     * Check if the log component is enabled.
     * @return true if the log component is enabled.
     */
    isEnabled(level: LogLevel): boolean;
    /**
     * Log on Trace level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    trace(fmt: string, ...args: any[]): any;
    /**
     * Log on Debug6 level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    debug6(fmt: string, ...args: any[]): any;
    /**
     * Log on Debug5 level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    debug5(fmt: string, ...args: any[]): any;
    /**
     * Log on Debug4 level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    debug4(fmt: string, ...args: any[]): any;
    /**
     * Log on Debug3 level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    debug3(fmt: string, ...args: any[]): any;
    /**
     * Log on Debug2 level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    debug2(fmt: string, ...args: any[]): any;
    /**
     * Log on Debug1 level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    debug1(fmt: string, ...args: any[]): any;
    /**
     * Log on Warn level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    warn(fmt: string, ...args: any[]): any;
    /**
     * Log on Error level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    error(fmt: string, ...args: any[]): any;
    /**
     * Log on Fatal level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    fatal(fmt: string, ...args: any[]): any;
    /**
     * Log on Meta level
     *
     * @param fmt Printf style format string, must be a string literal
     * @param args Arguments for the fmt string
     */
    meta(fmt: string, ...args: any[]): any;
}
/**
 * Metadata describing a log message
 */
export interface LogLineMetaData {
    /** Timestamp of when the message was logged */
    timestamp: number;
    /** The component in which the message was logged */
    component: LogComponent;
    /** The log level of the message */
    level: LogLevel;
}
export declare enum LogFileCompression {
    /** Default is to compress binary log files and not to compress text log files */
    UseDefault = 0,
    /** Enable compression of the log file */
    Compress = 1,
    /** Disable compression of the log file */
    Disabled = 2,
}
export declare enum LogFileEncoding {
    /** Write raw log data */
    Raw = 0,
    /** Encode the log file using base64 encoding */
    Base64 = 1,
}
export declare enum LogFileEncryption {
    /** Log file is not encrypted */
    Unencrypted = 0,
    /** Log file is encrypted */
    Encrypted = 1,
}
/**
 * Enumeration for eligible certificate formats coming out of these APIs
 */
export declare enum CertStoreFormat {
    /**
     * Traditional PEM format is used
     */
    PEM = 0,
    /**
     * DER format: binary.
     *
     * For public key X.509 SubjectPublicKeyInfo format is used
     */
    DER = 1,
    /**
     * BER format: binary.
     */
    BER = 2,
}
/**
 * Options for filtering a log buffer
 */
export interface FilterOptions {
    includeUnsafe?: boolean;
    reverse?: boolean;
    filter: {
        component: string;
        level: LogLevel;
    }[];
}
/**
 * Options for creating a log file
 */
export interface LogFileOptions {
    /**
     * Enable compression of log files.
     * Default is LogFileCompression.Compressed for binary log files and LogFileCompression.Disabled for text log files.
     */
    compression?: LogFileCompression;
    /**
     * Set log file encoding.
     * Default is LogFleEncoding.Raw.
     */
    encoding?: LogFileEncoding;
    /**
     * Set log file encryption.
     * Default is LogFileEncryption.Unencrypted.
     * An encryption key can be set using encryptionKey, or the default key can be used.
     */
    encryption?: LogFileEncryption;
    /**
     * Format of the optional encryptionKey property
     */
    encryptionKeyFormat?: CertStoreFormat;
    /**
     * Set a public RSA key to be used to encrypt the log file.
     * If no key is set, but encryption is enabled, a default key will be used.
     */
    encryptionKey?: string;
    /**
     * Max number of log files created by log file rotation.
     * Default is 10.
     * Set to zero to disable log rotation.
     */
    maxRotations?: number;
    /**
     * Max log file size.
     * If log rotation is used, this is the maximum size for each log file.
     * Default is 100Mb.
     * Set to zero to have unlimited size.
     */
    maxSize?: number;
    /**
     * Set a flag in the log file header that the log file is reversed. This should be used when
     * writing the log file from a LogBuffer in a reversed way.
     */
    reverse?: boolean;
}
/**
 * A log formatter decides how to format a log message, and can be assigned to an appender
 * for the appender to format all logs in a certain way.
 */
export interface ILogFormatter {
    /**
     * Format a log line to a string.
     *
     * Note!
     *  - A formatter might return null, in which case nothing should be logged.
     *
     * @param md Metadata for the log line
     * @param id Id of the log message
     * @param format printf-style format string, which will be null in release builds
     * @param args printf-style arguments used to populate the format string
     *
     * @return A formatted log line, or null if no line should be logged
     */
    format(md: LogLineMetaData, id: number, fmt: string, args: any[]): string;
}
/**
 * Flags used to indicate how an appender should be added
 */
export declare enum AppenderFlags {
    /**
     * Used when adding a filter to put the filter at the front of the current chain.
     * Default is to add the filter at the end of the current chain.
     */
    InsertFront = 8,
}
/**
 * A log appender represents a log output, such as a file or stdout.
 */
export interface ILogAppender {
    /**
     * Append a log line to the log
     *
     * @param md Metadata for the log line
     * @param id Id of the log message
     * @param format printf-style format string, which will be null in release builds
     * @param args printf-style arguments used to populate the format string
     */
    log(md: LogLineMetaData, logId: number, fmt: string, args: any[]): void;
    /**
     * If an appender returns true on this call, it will receive any log line that is enabled due to
     * either current global log level of the component, or due to any other appener enabling this
     * log line.
     * If this function returns false (default behaviour) log lines will be accepted according to
     * the regular rules using its threshold, forceThreshold, levels and the global log level config.
     *
     * This setting is different from forceThreshold in that the forceThreshold will force the log
     * level for all components, where as the receiveAll does not. It only recevies a log line if
     * it was enabled by any appender.
     *
     * @return true if to receive all log lines
     */
    receiveAll(): boolean;
    /**
     * This method can be implemented to have an appender give log levels for each component.
     * If this method returns null, each components log level is used as
     * usual.
     *
     * This appender will receive log lines according to the map returned from this function.
     * Each item in the list configures a component and its sub components, unless the sub
     * component is also explicitly mapped.
     * Any component which is not mentioned in the map, explicitly or implicitly by an ancestor,
     * will have the default log level.
     *
     * What this method returns does not affect what is received by any other appender.
     *
     * Note!
     * It's only recommended to override this method in very special cases, most appenders
     * should not override this method, and rely on the global log level configuration.
     *
     * @return A component->level map
     */
    levels(): {
        [component: string]: LogLevel;
    };
}
/**
 * Simple vsprintf implementation for JavaScript
 */
export declare function vsprintf(fmt: string, args: any[]): string;
/**
 * Simple sprintf implementation for JavaScript
 */
export declare function sprintf(fmt: string, ...args: any[]): string;
