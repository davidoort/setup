"use strict";
/*!
 *  AufLog.ts
 *  AUF
 *
 *  Created by Johan Blumenberg on 2016-12-29
 *  Copyright 2016 Microsoft. All rights reserved.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Log levels.
 *
 * The default log level is set to LL_Debug4. This can be overridden for each component by doing:
 *   auf.LogFactory.instance().component(name).setLevel(level);
 * Setting a log level will set it for that component and for all its sub components. Sub components
 * can then be set to a different log level.
 *
 * During normal program execution, the logs should be clean. Everything that shows in the log
 * is an indication of a bug (except the LL_MetaData level logs, which should be very sparse).
 *
 * Lower log levels can be used for troubleshooting a particular problem.
 *
 * Logs will be available on clients for debugging by developers, but they will also be
 * uploaded to the cloud from all released clients. Because of this, it is important that the
 * size of the log files can be controlled. The available bandwidth will limit the size of a log
 * file uploaded to the cloud. Logs that are more important for troubleshooting the problem should
 * have a less verbose level, and the more verbose levels can be filtered out to acheive the desired
 * log file size.
 */
var LogLevel;
(function (LogLevel) {
    /**
     * Trace level.
     * Suitable for logging function entry/exit.
     */
    LogLevel[LogLevel["Trace"] = 10] = "Trace";
    /**
     * The most detailed debug level, suitable for logging anything that can help a developer to understand
     * the flow of the application. There is no limit on the size of the logs on level LL_Debug6, but they will
     * likely not be uploaded to the cloud due to their size.
     * On level LL_Debug6 it is allowed to log large strings or other contents that require more memory to
     * handle on the client. It is not allowed on the less detailed debug levels.
     */
    LogLevel[LogLevel["Debug6"] = 16] = "Debug6";
    /**
     * Log level suitable for logging most low level events except for large chunks of data or large strings.
     */
    LogLevel[LogLevel["Debug5"] = 18] = "Debug5";
    /**
     * Log level suitable for logging most low level events except for large chunks of data or large strings.
     *
     * Note: Default log level is set to Debug4.
     */
    LogLevel[LogLevel["Debug4"] = 20] = "Debug4";
    /**
     * Log level suitable for logging a more detailed flow of events in the application.
     */
    LogLevel[LogLevel["Debug3"] = 30] = "Debug3";
    /**
     * Log level suitable for logging a more detailed flow of events in the application.
     */
    LogLevel[LogLevel["Debug2"] = 40] = "Debug2";
    /**
     * The least detailed debug level, suitable for logging of significant events in the application, for
     * example call started, call ended, or user login.
     * The goal is to be able to upload all LL_Debug1 logs for an entire call to the cloud after the call
     * is complete, also on devices that have limited bandwidth and memory.
     */
    LogLevel[LogLevel["Debug1"] = 50] = "Debug1";
    /**
     * Suitable for logging a warning when the app faced a potential problem that was mitigated without
     * affecting the user experience in any way.
     * Some examples are:
     * 1) When an external service could not be used, but a secondary service which performs the same
     * functions was available.
     * 2) When repeated attempts unexpectedly were required to access a given resource.
     * 3) When authentication fails, because this is most likely not an error but due to bad user input,
     * but it is very useful information when troubleshooting.
     */
    LogLevel[LogLevel["Warning"] = 60] = "Warning";
    /**
     * Error level.
     * Suitable for logging a significant problem that affected the user in some way.
     * For example, a database connection that failed, resulting in parts of the app being unusable.
     *
     * Something that might be an error, but might also be normal operation, should not be logged as
     * an error. For example, a library call failing to connect a socket or failing to lookup a host
     * name should be logged on a more verbose level, since that could also be normal operation.
     * Higher layers in the code should determine if it is considered an error, and make the appropriate
     * log. Enabling more verbose logs will then give more details about the error.
     */
    LogLevel[LogLevel["Error"] = 70] = "Error";
    /**
     * Fatal errors.
     * Suitable for logging errors that are so serious that the program will abort.
     */
    LogLevel[LogLevel["Fatal"] = 80] = "Fatal";
    /**
     * Suitable for logging information that would be useful to diagnose the app without access to the
     * device.
     * For example app and os versions.
     */
    LogLevel[LogLevel["MetaData"] = 90] = "MetaData";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var LogFileCompression;
(function (LogFileCompression) {
    /** Default is to compress binary log files and not to compress text log files */
    LogFileCompression[LogFileCompression["UseDefault"] = 0] = "UseDefault";
    /** Enable compression of the log file */
    LogFileCompression[LogFileCompression["Compress"] = 1] = "Compress";
    /** Disable compression of the log file */
    LogFileCompression[LogFileCompression["Disabled"] = 2] = "Disabled";
})(LogFileCompression = exports.LogFileCompression || (exports.LogFileCompression = {}));
var LogFileEncoding;
(function (LogFileEncoding) {
    /** Write raw log data */
    LogFileEncoding[LogFileEncoding["Raw"] = 0] = "Raw";
    /** Encode the log file using base64 encoding */
    LogFileEncoding[LogFileEncoding["Base64"] = 1] = "Base64";
})(LogFileEncoding = exports.LogFileEncoding || (exports.LogFileEncoding = {}));
var LogFileEncryption;
(function (LogFileEncryption) {
    /** Log file is not encrypted */
    LogFileEncryption[LogFileEncryption["Unencrypted"] = 0] = "Unencrypted";
    /** Log file is encrypted */
    LogFileEncryption[LogFileEncryption["Encrypted"] = 1] = "Encrypted";
})(LogFileEncryption = exports.LogFileEncryption || (exports.LogFileEncryption = {}));
/**
 * Enumeration for eligible certificate formats coming out of these APIs
 */
var CertStoreFormat;
(function (CertStoreFormat) {
    /**
     * Traditional PEM format is used
     */
    CertStoreFormat[CertStoreFormat["PEM"] = 0] = "PEM";
    /**
     * DER format: binary.
     *
     * For public key X.509 SubjectPublicKeyInfo format is used
     */
    CertStoreFormat[CertStoreFormat["DER"] = 1] = "DER";
    /**
     * BER format: binary.
     */
    CertStoreFormat[CertStoreFormat["BER"] = 2] = "BER";
})(CertStoreFormat = exports.CertStoreFormat || (exports.CertStoreFormat = {}));
;
/**
 * Flags used to indicate how an appender should be added
 */
var AppenderFlags;
(function (AppenderFlags) {
    /**
     * Used when adding a filter to put the filter at the front of the current chain.
     * Default is to add the filter at the end of the current chain.
     */
    AppenderFlags[AppenderFlags["InsertFront"] = 8] = "InsertFront";
})(AppenderFlags = exports.AppenderFlags || (exports.AppenderFlags = {}));
/**
 * Simple vsprintf implementation for JavaScript
 */
function vsprintf(fmt, args) {
    var n = 0;
    return fmt.replace(/%[dixs%]/g, function (fmt) {
        var p = 0;
        if (fmt[p++] !== '%') {
            return '';
        }
        var c = fmt[p++];
        if (c === '%') {
            return '%';
        }
        else if (c === 's') {
            return args[n++];
        }
        else if (c === 'd' || c === 'i') {
            return args[n++];
        }
        else if (c === 'x') {
            return args[n++].toString(16);
        }
        else {
            return fmt;
        }
    });
}
exports.vsprintf = vsprintf;
/**
 * Simple sprintf implementation for JavaScript
 */
function sprintf(fmt) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return vsprintf(fmt, args);
}
exports.sprintf = sprintf;
